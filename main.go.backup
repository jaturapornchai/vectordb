package main

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

type Config struct {
	DBHost      string
	DBPort      string
	DBUser      string
	DBPassword  string
	DBName      string
	OllamaHost  string
	OllamaModel string
}

// OllamaEmbeddingRequest represents the request to Ollama API
type OllamaEmbeddingRequest struct {
	Model  string `json:"model"`
	Prompt string `json:"prompt"`
}

// OllamaEmbeddingResponse represents the response from Ollama API
type OllamaEmbeddingResponse struct {
	Embedding []float32 `json:"embedding"`
}

func loadConfig() *Config {
	// Load .env file
	if err := godotenv.Load(); err != nil {
		log.Println("Warning: .env file not found, using environment variables")
	}

	ollamaHost := os.Getenv("OLLAMA_HOST")
	if ollamaHost == "" {
		ollamaHost = "http://ollama:11434"
	}

	ollamaModel := os.Getenv("OLLAMA_MODEL")
	if ollamaModel == "" {
		ollamaModel = "qwen2.5:0.5b"
	}

	return &Config{
		DBHost:      os.Getenv("DB_HOST"),
		DBPort:      os.Getenv("DB_PORT"),
		DBUser:      os.Getenv("DB_USER"),
		DBPassword:  os.Getenv("DB_PASSWORD"),
		DBName:      os.Getenv("DB_NAME"),
		OllamaHost:  ollamaHost,
		OllamaModel: ollamaModel,
	}
}

func connectDB(cfg *Config) (*sql.DB, error) {
	// Create connection string
	connStr := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		cfg.DBHost, cfg.DBPort, cfg.DBUser, cfg.DBPassword, cfg.DBName,
	)

	// Open database connection
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Set connection pool settings
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(5)
	db.SetConnMaxLifetime(5 * time.Minute)

	// Test connection
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return db, nil
}

func createTestVectorDB(cfg *Config) error {
	// Connect to default postgres database to create new database
	connStr := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=postgres sslmode=disable",
		cfg.DBHost, cfg.DBPort, cfg.DBUser, cfg.DBPassword,
	)

	db, err := sql.Open("postgres", connStr)
	if err != nil {
		return fmt.Errorf("failed to connect to postgres: %w", err)
	}
	defer db.Close()

	// Check if database exists
	var exists bool
	err = db.QueryRow("SELECT EXISTS(SELECT 1 FROM pg_database WHERE datname = 'testvector')").Scan(&exists)
	if err != nil {
		return fmt.Errorf("failed to check database existence: %w", err)
	}

	if !exists {
		// Create database
		_, err = db.Exec("CREATE DATABASE testvector")
		if err != nil {
			return fmt.Errorf("failed to create database: %w", err)
		}
		log.Println("Database 'testvector' created successfully")
	} else {
		log.Println("Database 'testvector' already exists")
	}

	return nil
}

func connectTestVectorDB(cfg *Config) (*sql.DB, error) {
	// Create connection string for testvector database
	connStr := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=testvector sslmode=disable",
		cfg.DBHost, cfg.DBPort, cfg.DBUser, cfg.DBPassword,
	)

	// Open database connection
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Set connection pool settings
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(5)
	db.SetConnMaxLifetime(5 * time.Minute)

	// Test connection
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := db.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return db, nil
}

func setupPgVector(db *sql.DB) error {
	ctx := context.Background()

	// Create pgvector extension if not exists
	_, err := db.ExecContext(ctx, "CREATE EXTENSION IF NOT EXISTS vector")
	if err != nil {
		return fmt.Errorf("failed to create vector extension: %w", err)
	}

	log.Println("pgvector extension created successfully")

	// Create example table with vector column
	createTableSQL := `
	CREATE TABLE IF NOT EXISTS embeddings (
		id SERIAL PRIMARY KEY,
		content TEXT NOT NULL,
		embedding vector(1024),
		created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
	)`

	_, err = db.ExecContext(ctx, createTableSQL)
	if err != nil {
		return fmt.Errorf("failed to create embeddings table: %w", err)
	}

	log.Println("Embeddings table created successfully")

	// Create index for vector similarity search
	createIndexSQL := `
	CREATE INDEX IF NOT EXISTS embeddings_embedding_idx 
	ON embeddings USING ivfflat (embedding vector_cosine_ops)
	WITH (lists = 100)`

	_, err = db.ExecContext(ctx, createIndexSQL)
	if err != nil {
		// Index creation might fail if there's no data yet, which is okay
		log.Printf("Warning: failed to create index (this is normal if table is empty): %v", err)
	} else {
		log.Println("Vector index created successfully")
	}

	return nil
}

func main() {
	log.Println("Starting Vector Database Application...")

	// Load configuration
	cfg := loadConfig()

	// Connect to database
	db, err := connectDB(cfg)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer db.Close()

	log.Printf("Successfully connected to PostgreSQL at %s:%s", cfg.DBHost, cfg.DBPort)

	// Setup pgvector
	if err := setupPgVector(db); err != nil {
		log.Fatalf("Failed to setup pgvector: %v", err)
	}

	log.Println("Vector database is ready!")

	// Example: Insert a sample embedding (placeholder with zeros)
	insertSQL := `
	INSERT INTO embeddings (content, embedding) 
	VALUES ($1, $2)
	ON CONFLICT DO NOTHING`

	// Create a sample 1024-dimensional vector (all zeros for demonstration)
	sampleVector := make([]float32, 1024)
	for i := range sampleVector {
		sampleVector[i] = 0.0
	}

	// Convert to string format for PostgreSQL vector type
	vectorStr := "["
	for i, v := range sampleVector {
		if i > 0 {
			vectorStr += ","
		}
		vectorStr += fmt.Sprintf("%f", v)
	}
	vectorStr += "]"

	_, err = db.Exec(insertSQL, "Sample content", vectorStr)
	if err != nil {
		log.Printf("Failed to insert sample embedding: %v", err)
	} else {
		log.Println("Sample embedding inserted successfully")
	}

	// Query example: Get all embeddings
	rows, err := db.Query("SELECT id, content, created_at FROM embeddings LIMIT 5")
	if err != nil {
		log.Printf("Failed to query embeddings: %v", err)
	} else {
		defer rows.Close()
		log.Println("\nStored embeddings:")
		for rows.Next() {
			var id int
			var content string
			var createdAt time.Time
			if err := rows.Scan(&id, &content, &createdAt); err != nil {
				log.Printf("Failed to scan row: %v", err)
				continue
			}
			log.Printf("  ID: %d, Content: %s, Created: %s", id, content, createdAt.Format(time.RFC3339))
		}
	}

	log.Println("\nApplication is running. Press Ctrl+C to exit.")
	// Keep the application running
	select {}
}
